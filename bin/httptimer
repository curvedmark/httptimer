#!/usr/bin/env node
'use strict';

var Q = require('q');
var program = require('commander');
var httptimer = require('../lib/httptimer');
var version = require('../package.json').version;

program
	.version(version, '-v, --version')
	.usage('[options] [urls ...]')
	.option('-p, --parallel <count>', 'Number of urls to test in parallel')
	.option('-r, --repeat <times>', 'Number of times to test repeatly')
	.option('-t, --timeout <ms>', 'Timeout for http request')
	.option('-a, --appendix <path>', 'Append path to urls')
	.parse(process.argv);

if (typeof program.parallel === 'string') {
	program.parallel = +program.parallel;
}
if (typeof program.repeat === 'string') {
	program.repeat = +program.repeat;
}
if (typeof program.timeout === 'string') {
	program.timeout = +program.timeout;
}

var urls = program.args;
if (!urls.length) {
	urls = readStdin();
}

Q(urls).then(function (urls) {
	var maxLength = urls.reduce(function (maxLength, url) {
		return Math.max(maxLength, url.length);
	}, 0);
	httptimer.start(urls, program).then(function (rtts) {
		rtts.map(function (rtt, i) {
			return [urls[i], rtt];
		}).sort(function (entry1, entry2) {
			return entry1[1] > entry2[1];
		}).map(function (entry) {
			var url = entry[0];
			var rtt = entry[1];
			var output = url + padding(url, maxLength) + rtt;

			console.log(output);
		});
	});
});

function readStdin() {
	var deferred = Q.defer();

	var stdin = '';
	process.stdin.resume();
	process.stdin.setEncoding('utf8');
	process.stdin.on('data', function (chunk) {
		stdin += chunk;
	});
	process.stdin.on('end', function () {
		var lines = stdin.trim().split('\n');
		deferred.resolve(lines);
	});

	return deferred.promise;
}

function padding(url, maxLength) {
	return new Array(maxLength - url.length + 1).join(' ') + '  ';
}