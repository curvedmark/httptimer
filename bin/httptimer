#!/usr/bin/env node
'use strict';

var Q = require('q');
var program = require('commander');
var httptimer = require('../lib/httptimer');
var version = require('../package.json').version;

program
	.version(version, '-v, --version')
	.usage('[options] [urls ...]')
	.option('-p, --parallel <count>', 'Number of urls to test in parallel')
	.option('-r, --repeat <times>', 'Number of times to test repeatly')
	.option('-t, --timeout <ms>', 'Timeout for http request')
	.option('-h, --host', 'Display hostname along with RTT')
	.parse(process.argv);

if (typeof program.parallel === 'string') {
	program.parallel = +program.parallel;
}
if (typeof program.repeat === 'string') {
	program.repeat = +program.repeat;
}
if (typeof program.timeout === 'string') {
	program.timeout = +program.timeout;
}

var urls = program.args;
if (!urls.length) {
	urls = readStdin();
}

Q(urls).then(function (urls) {
	httptimer.start(urls, program).then(function (rtts) {
		rtts.forEach(function (rtt, i) {
			var output = rtt;
			if (program.host) {
				output = urls[i] + '	' + output;
			}

			console.log(output);
		});
	});
});

function readStdin() {
	var deferred = Q.defer();

	var stdin = '';
	process.stdin.resume();
	process.stdin.setEncoding('utf8');
	process.stdin.on('data', function (chunk) {
		stdin += chunk;
	});
	process.stdin.on('end', function () {
		var lines = stdin.trim().split('\n');
		deferred.resolve(lines);
	});

	return deferred.promise;
}